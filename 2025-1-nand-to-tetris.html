<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=device-width, minimal-ui, initial-scale=1, viewport-fit=cover">

        <title>[WIP] The Elements of Computing Systems – Building a Modern Computer from First Principles</title>
        <meta property="og:image" content="assets/banners/2025-1-nand-to-tetris.jpg">
        <meta property="og:type" content="article">

        <link rel="icon" type="image/png" href="assets/favicon.ico">
        <link rel="apple-touch-icon" sizes="180x180" href="assets/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="assets/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="assets/favicon-16x16.png">

        <link href="assets/main.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css" integrity="sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X" crossorigin="anonymous">
    </head>
    <body>
    <h1>[WIP] The Elements of Computing Systems – Building a Modern Computer from First Principles</h1>
<h2>Chapter 1: Boolean logic</h2>
<p>Modern computers store and process information stored as two-valued signals — called <code>bits</code> (i.e. binary digits). Two-value signals were chosen because they can readily be represented, stored, and transmitted. For example, they can be represented as:</p>
<ul>
<li>The presence or absence of a hole in a punched card,</li>
<li>High or low voltage on a wire,</li>
<li>A magnetic domain oriented clockwise or counterclockwise.</li>
</ul>
<p>A binary variable or a bit can represent two possible states: <code>0</code> and <code>1</code>; <code>off</code> and <code>on</code>; <code>false</code> and <code>true</code>; <code>no</code> and <code>yes</code>; etc. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> binary variables can be used to represent <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> states. e.g.</p>
<table>
<thead>
<tr>
<th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">b_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></th>
<th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></th>
<th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">b_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<hr>
<p><mark>Boolean algebra</mark> is used to manipulate binary values. <mark>A boolean function (aka boolean operator) is a function that operates on binary inputs and returns binary outputs</mark>.</p>
<p>The total number of boolean functions for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> binary variables is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><msup><mn>2</mn><mi>n</mi></msup></msup></mrow><annotation encoding="application/x-tex">2^{2^n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.88em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.88em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7385em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>, because:</p>
<ul>
<li>There are $2^n$ input combinations.</li>
<li>Each of these input combinations can be mapped to either <code>0</code> or <code>1</code>.</li>
<li>Therefore, the total number of boolean functions is: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><msup><mn>2</mn><mi>n</mi></msup></msup></mrow><annotation encoding="application/x-tex">2^{2^n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.88em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.88em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7385em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li>
</ul>
<p>e.g. There are <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span></span></span></span> distinct boolean functions for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> binary variables.</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Expression</th>
<th>A=0, B=0</th>
<th>A=0, B=1</th>
<th>A=1, B=0</th>
<th>A=1, B=1</th>
</tr>
</thead>
<tbody><tr>
<td>F0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>F1</td>
<td>NOT A AND NOT B</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>F2</td>
<td>NOT A AND B</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>F3</td>
<td>NOT A</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>F4</td>
<td>A AND NOT B</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>F5</td>
<td>NOT B</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>F6</td>
<td>XOR(A, B)</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>F7</td>
<td>NAND(A, B)</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>F8</td>
<td>A AND B</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>F9</td>
<td>XNOR(A, B)</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>F10</td>
<td>B</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>F11</td>
<td>NOT A OR B</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>F12</td>
<td>A</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>F13</td>
<td>A OR NOT B</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>F14</td>
<td>A OR B</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>F15</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<hr>
<p>A <mark>logic gate</mark> <mark>(also called <strong>chip</strong> in the book) is a physical device that implements a boolean function</mark>. Every digital device is based on a set of chips designed to store and process binary information. These chips are all made of <strong>elementary logic gates</strong>. Elementary logic gates can be physically realized using many different hardware technologies, but their logical behavior, or abstraction, is consistent across implementations.</p>
<p>Since all logic gates have the same input and output data type (i.e. binary), they can be combined, creating composite gates of arbitrary complexity. e.g. <code>Xor = Or(And(a, Not(b)), And(Not(a), b))</code>.</p>
<p>Any given logic gate can be viewed from two perspective:</p>
<ol>
<li><strong>External</strong>: The interface of the gate, outlining its input pins, output pins, and its behavior.</li>
<li><strong>Internal</strong>: The implementation of the gate. There can be multiple implementations of a gate’s interface. The goal is to find an implementation that is correct (functional requirement) and efficient (performance requirement).</li>
</ol>
<hr>
<p>A <mark>hardware description language (HDL)</mark> is a specialized computer language used to describe the structure and behavior of chips.</p>
<blockquote>
<p>The designer specifies the chip logic by writing a HDL program, which is then subjected to a rigorous battery of tests. The tests are carried out virtually, using computer simulation: A special software tool, called a <strong>hardware simulator</strong>, takes the HDL program as input and creates a software representation of the chip logic. Next, the designer can instruct the simulator to test the virtual chip on various sets of inputs. The simulator computes the chip outputs, which are then compared to the desired outputs.</p>
</blockquote>
<p>The hardware simulator can also simulate and quantify the performance characteristics (energy consumption, computational speed, cost) of a chip.</p>
<hr>
<p>The <mark>specifications of the logic gates</mark> needed to build the chips of our computer system are given below.</p>
<hr>
<p>First, the <strong>primitive</strong> <mark>NAND</mark> gate, which is shorthand for <strong>Not-And</strong> because it’s equivalent to <code>Not(And(a, b))</code>.</p>
<p><img src="assets/nand-images/nand_gate.svg" alt=""></p>
<p>Truth table:</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>Nand(a, b)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<p>API:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Chip name</td>
<td><code>Nand</code></td>
</tr>
<tr>
<td>Input</td>
<td><code>a</code>, <code>b</code></td>
</tr>
<tr>
<td>Output</td>
<td><code>out</code></td>
</tr>
<tr>
<td>Function</td>
<td><code>if ((a == 1) and (b==1)) then out = 0, else out = 1</code></td>
</tr>
</tbody></table>
<p>The NAND gate is called a primitive gate because it can be used to implement any boolean function. Proof:</p>
<ul>
<li><p>Various subsets of logical operators can be used for expressing any boolean function, and <code>{ And, Or, Not }</code> is one such subset. NAND can be used to implement each member of the subset as demonstrated below.</p>
</li>
<li><p><code>NOT(a) = NAND(a, a)</code></p>
</li>
<li><p><code>AND(a, b) = NOT(NAND(a, b))</code></p>
</li>
<li><p><code>OR(a, b) = NOT(NOT(a) AND NOT(b))</code> (De morgan law); This is equivalent to: <code>OR(a, b) = NAND(NOT(a), NOT(b))</code></p>
</li>
</ul>
<hr>
<p>Next, we look at a set of four gates that implement <strong>classical logical operators</strong>. Starting with the <mark>Not (aka inverter) gate</mark>, which outputs the opposite value of its input’s value.</p>
<p><img src="assets/nand-images/not_gate.svg" alt=""></p>
<p>Truth table:</p>
<table>
<thead>
<tr>
<th>a</th>
<th>Not(a)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<p>API:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Chip name</td>
<td><code>Not</code></td>
</tr>
<tr>
<td>Input</td>
<td><code>in</code></td>
</tr>
<tr>
<td>Output</td>
<td><code>out</code></td>
</tr>
<tr>
<td>Function</td>
<td><code>if (in == 0) then out = 1, else out = 0</code></td>
</tr>
</tbody></table>
<p>HDL:</p>
<pre><code class="hljs language-hdl">
CHIP Not {

IN in;

OUT out;

  

PARTS:

Nand(a= in, b= in, out= out);

}
</code></pre><hr>
<p>The next classical gate is the <mark>AND gate</mark>, which returns <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> when both its inputs are <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> otherwise.</p>
<p><img src="assets/nand-images/and_gate.svg" alt=""></p>
<p>Truth table:  </p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>And(a, b)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>API:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Chip name</td>
<td><code>And</code></td>
</tr>
<tr>
<td>Input</td>
<td><code>a</code>, <code>b</code></td>
</tr>
<tr>
<td>Output</td>
<td><code>out</code></td>
</tr>
<tr>
<td>Function</td>
<td><code>if ((a == 1) and (b==1)) then out = 1, else out = 0</code></td>
</tr>
</tbody></table>
<p>HDL:</p>
<pre><code class="hljs language-hdl">
CHIP And {

IN a, b;

OUT out;

PARTS:

Nand(a= a, b= b, out= nandout);

Not(in= nandout, out= out);

}
</code></pre><hr>
<p>The <mark>Or gate</mark> returns <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> when at least one of its inputs is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> otherwise.</p>
<p><img src="assets/nand-images/or_gate.svg" alt=""></p>
<p>Truth table:</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>Or(a, b)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>API:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Chip name</td>
<td><code>Or</code></td>
</tr>
<tr>
<td>Input</td>
<td><code>a</code>, <code>b</code></td>
</tr>
<tr>
<td>Output</td>
<td><code>out</code></td>
</tr>
<tr>
<td>Function</td>
<td><code>if ((a == 0) and (b == 0)) then out = 0, else out = 1</code></td>
</tr>
</tbody></table>
<p>HDL:</p>
<pre><code class="hljs language-hdl">
CHIP Or {

IN a, b;

OUT out;

  

PARTS:

Not(in= a, out= nota);

Not(in= b, out= notb);

And(a= nota, b= notb, out= notaandnotb);

Not(in= notaandnotb, out= out);

}
</code></pre><hr>
<p>The last classical gate we will build is the <mark>Xor (aka exclusive or) gate</mark> which returns <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> when exactly one of its input is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> otherwise.</p>
<p><img src="assets/nand-images/xor_gate.svg" alt=""></p>
<p>Truth table:</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>Xor(a, b)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<p>API:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Chip name</td>
<td><code>Xor</code></td>
</tr>
<tr>
<td>Input</td>
<td><code>a</code>, <code>b</code></td>
</tr>
<tr>
<td>Output</td>
<td><code>out</code></td>
</tr>
<tr>
<td>Function</td>
<td><code>if (a != b) then out = 1, else out = 0</code></td>
</tr>
</tbody></table>
<p>HDL:</p>
<pre><code class="hljs language-hdl">
CHIP Xor {

IN a, b;

OUT out;

  

PARTS:

Not(in= a, out= nota);

Not(in= b, out= notb);

And(a= a, b= notb, out= aandnotb);

And(a= b, b= nota, out= bandnota);

Or(a= aandnotb, b= bandnota, out= out);

}
</code></pre><hr>
<p>Next, we look at a set of <mark>control flow gates</mark>. These gates provide means for controlling flows of information. The first of such gate is the <mark>multiplexer</mark> which is a three-input gate. Two input bits, named <code>a</code> and <code>b</code>, are interpreted as <strong>data bits</strong>, and a third bit, named <code>sel</code>, is interpreted as a <strong>selection bit</strong>. The multiplexer uses <code>sel</code> to select and output the value of either <code>a</code> or <code>b</code>.</p>
<p><img src="assets/nand-images/multiplexer_gate.png" alt=""></p>
<p>Truth table:</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>sel</th>
<th>out</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>API:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Chip name</td>
<td><code>Mux</code></td>
</tr>
<tr>
<td>Input</td>
<td><code>a</code>, <code>b</code>, <code>sel</code></td>
</tr>
<tr>
<td>Output</td>
<td><code>out</code></td>
</tr>
<tr>
<td>Function</td>
<td><code>if (sel == 0) then out = a, else out = b</code></td>
</tr>
</tbody></table>
<p>HDL:</p>
<pre><code class="hljs language-hdl">
CHIP Mux {

IN a, b, sel;

OUT out;

  

PARTS:

Not(in= sel, out= notsel);

And(a= a, b= notsel, out= aandnotsel);

And(a= b, b= sel, out= bandsel);

Or(a= aandnotsel, b= bandsel, out= out);

}
</code></pre><hr>
<p>Next is the <mark>demultiplexer gate</mark> which performs the opposite function of a multiplexer: it takes a single input value and routes it to one of two possible outputs, according to a selector bit that selects the destination output.</p>
<p><img src="assets/nand-images/demultiplexer_gate.png" alt=""></p>
<table>
<thead>
<tr>
<th>in</th>
<th>sel</th>
<th>a</th>
<th>b</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p>API:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Chip name</td>
<td><code>DMux</code></td>
</tr>
<tr>
<td>Input</td>
<td><code>in</code>, <code>sel</code></td>
</tr>
<tr>
<td>Output</td>
<td><code>a</code>, <code>b</code></td>
</tr>
<tr>
<td>Function</td>
<td><code>if (sel == 0) then {a, b} = {in, 0}, else {a, b} = {0, in} </code></td>
</tr>
</tbody></table>
<p>HDL:</p>
<pre><code class="hljs language-hdl">
CHIP DMux {

IN in, sel;

OUT a, b;

  

PARTS:

Not(in= sel, out= notsel);

And(a= in, b= notsel, out= a);

And(a= in, b= sel, out= b);

}
</code></pre><hr>
<p>Now, we explore <mark>multi-bit versions of some of the basic gates</mark> above. This section describes several 16-bit logic gates that will be needed for constructing our target computer platform. HDL programs treat multi-bit values like single-bit values, except that the values can be indexed in order to access individual bits. For example, if <code>in</code> and <code>out</code> represent 16-bit values, then <code>out [3] = in[5]</code> sets the 3rd bit of <code>out</code> to the value of the 5th bit of <code>in</code>. The bits are indexed from right to left, the rightmost bit being the 0’th bit and the leftmost bit being the 15’th bit (in a 16-bit setting).</p>
<hr>
<p>The first multi-bit gate we will build is the <mark>16-bit Not gate</mark>, which applies the Boolean operation <code>Not</code> to every one of the input bits.</p>
<p>API:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Chip name</td>
<td><code>Not16</code></td>
</tr>
<tr>
<td>Input</td>
<td><code>in[16]</code></td>
</tr>
<tr>
<td>Output</td>
<td><code>out[16]</code></td>
</tr>
<tr>
<td>Function</td>
<td><code>for i = 0..15 out[i] = Not(in[i])</code></td>
</tr>
</tbody></table>
<p>HDL:</p>
<pre><code class="hljs language-hdl">
CHIP Not16 {

IN in[16];

OUT out[16];

  

PARTS:

Not(in= in[0], out= out[0]);

Not(in= in[1], out= out[1]);

Not(in= in[2], out= out[2]);

Not(in= in[3], out= out[3]);

Not(in= in[4], out= out[4]);

Not(in= in[5], out= out[5]);

Not(in= in[6], out= out[6]);

Not(in= in[7], out= out[7]);

Not(in= in[8], out= out[8]);

Not(in= in[9], out= out[9]);

Not(in= in[10], out= out[10]);

Not(in= in[11], out= out[11]);

Not(in= in[12], out= out[12]);

Not(in= in[13], out= out[13]);

Not(in= in[14], out= out[14]);

Not(in= in[15], out= out[15]);

}
</code></pre><hr>
<p>Next is the <mark>16-bit And gate</mark>, which applies the Boolean operation <code>And</code> to every one of the input bits.</p>
<p>API:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Chip name</td>
<td><code>And16</code></td>
</tr>
<tr>
<td>Input</td>
<td><code>a[16]</code>, <code>b[16]</code></td>
</tr>
<tr>
<td>Output</td>
<td><code>out[16]</code></td>
</tr>
<tr>
<td>Function</td>
<td><code>for i = 0..15 out[i] = And(a[i], b[i])</code></td>
</tr>
</tbody></table>
<p>HDL:</p>
<pre><code class="hljs language-hdl">
CHIP And16 {

IN a[16], b[16];

OUT out[16];

  

PARTS:

And(a= a[0], b= b[0], out= out[0]);

And(a= a[1], b= b[1], out= out[1]);

And(a= a[2], b= b[2], out= out[2]);

And(a= a[3], b= b[3], out= out[3]);

And(a= a[4], b= b[4], out= out[4]);

And(a= a[5], b= b[5], out= out[5]);

And(a= a[6], b= b[6], out= out[6]);

And(a= a[7], b= b[7], out= out[7]);

And(a= a[8], b= b[8], out= out[8]);

And(a= a[9], b= b[9], out= out[9]);

And(a= a[10], b= b[10], out= out[10]);

And(a= a[11], b= b[11], out= out[11]);

And(a= a[12], b= b[12], out= out[12]);

And(a= a[13], b= b[13], out= out[13]);

And(a= a[14], b= b[14], out= out[14]);

And(a= a[15], b= b[15], out= out[15]);

}
</code></pre><hr>
<p>Followed by the <mark>16-bit Or gate</mark>, which applies the Boolean operation <code>Or</code> to every one of the input bits.</p>
<p>API:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Chip name</td>
<td><code>Or16</code></td>
</tr>
<tr>
<td>Input</td>
<td><code>a[16]</code>, <code>b[16]</code></td>
</tr>
<tr>
<td>Output</td>
<td><code>out[16]</code></td>
</tr>
<tr>
<td>Function</td>
<td><code>for i = 0..15 out[i] = Or(a[i], b[i])</code></td>
</tr>
</tbody></table>
<p>HDL:</p>
<pre><code class="hljs language-hdl">
CHIP Or16 {

IN a[16], b[16];

OUT out[16];

  

PARTS:

Or(a= a[0], b= b[0], out= out[0]);

Or(a= a[1], b= b[1], out= out[1]);

Or(a= a[2], b= b[2], out= out[2]);

Or(a= a[3], b= b[3], out= out[3]);

Or(a= a[4], b= b[4], out= out[4]);

Or(a= a[5], b= b[5], out= out[5]);

Or(a= a[6], b= b[6], out= out[6]);

Or(a= a[7], b= b[7], out= out[7]);

Or(a= a[8], b= b[8], out= out[8]);

Or(a= a[9], b= b[9], out= out[9]);

Or(a= a[10], b= b[10], out= out[10]);

Or(a= a[11], b= b[11], out= out[11]);

Or(a= a[12], b= b[12], out= out[12]);

Or(a= a[13], b= b[13], out= out[13]);

Or(a= a[14], b= b[14], out= out[14]);

Or(a= a[15], b= b[15], out= out[15]);

}
</code></pre><hr>
<p>Finally, the <mark>16-bit Multiplexer gate</mark>, which operates exactly as the basic multiplexer, except that its input and output are 16-bits wide.</p>
<p>API:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Chip name</td>
<td><code>Mux16</code></td>
</tr>
<tr>
<td>Input</td>
<td><code>a[16]</code>, <code>b[16]</code>, <code>sel</code></td>
</tr>
<tr>
<td>Output</td>
<td><code>out[16]</code></td>
</tr>
<tr>
<td>Function</td>
<td><code>if (sel == 0) then for i = 0..15 out[i] = a[i], else for i = 0..15 out[i] = b[i]</code></td>
</tr>
</tbody></table>
<p>HDL:</p>
<pre><code class="hljs language-hdl">
CHIP Mux16 {

IN a[16], b[16], sel;

OUT out[16];

  

PARTS:

Mux(a= a[0], b= b[0], sel= sel, out= out[0]);

Mux(a= a[1], b= b[1], sel= sel, out= out[1]);

Mux(a= a[2], b= b[2], sel= sel, out= out[2]);

Mux(a= a[3], b= b[3], sel= sel, out= out[3]);

Mux(a= a[4], b= b[4], sel= sel, out= out[4]);

Mux(a= a[5], b= b[5], sel= sel, out= out[5]);

Mux(a= a[6], b= b[6], sel= sel, out= out[6]);

Mux(a= a[7], b= b[7], sel= sel, out= out[7]);

Mux(a= a[8], b= b[8], sel= sel, out= out[8]);

Mux(a= a[9], b= b[9], sel= sel, out= out[9]);

Mux(a= a[10], b= b[10], sel= sel, out= out[10]);

Mux(a= a[11], b= b[11], sel= sel, out= out[11]);

Mux(a= a[12], b= b[12], sel= sel, out= out[12]);

Mux(a= a[13], b= b[13], sel= sel, out= out[13]);

Mux(a= a[14], b= b[14], sel= sel, out= out[14]);

Mux(a= a[15], b= b[15], sel= sel, out= out[15]);

}
</code></pre><hr>
<p>The last set of gates we will build are the <mark>multi-way versions of basic gates</mark>. Logic gates that operate on one or two inputs have natural generalization to multi-way variants that operate on more than two inputs.</p>
<hr>
<p>The first gate in this set is the <mark>multi-way Or gate</mark>. An $m$-way <code>Or</code> gate outputs <code>1</code> when at least one of its <code>m</code> input bits is <code>1</code>, and <code>0</code> otherwise. Our target computer will need an $8$-way variant of this gate:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Chip name</td>
<td><code>Or8Way</code></td>
</tr>
<tr>
<td>Input</td>
<td><code>in[8]</code></td>
</tr>
<tr>
<td>Output</td>
<td><code>out</code></td>
</tr>
<tr>
<td>Function</td>
<td><code>out = Or(in[0], in[1], ..., in[7])</code></td>
</tr>
</tbody></table>
<pre><code class="hljs language-hdl">CHIP Or8Way {

IN in[8];

OUT out;

  

PARTS:

Or(a= in[0], b= in[1], out= in01);

Or(a= in01, b= in[2], out= in012);

Or(a= in012, b= in[3], out= in0123);

Or(a= in0123, b= in[4], out= in01234);

Or(a= in01234, b= in[5], out= in012345);

Or(a= in012345, b= in[6], out= in0123456);

Or(a= in0123456, b= in[7], out= out);

}
</code></pre><hr>
<p>Next, we build a <mark>multi-way multi-bit multiplexer gate</mark>. An <span class="katex-error" title="ParseError: KaTeX parse error: Can&#x27;t use function &#x27;<!-- output_content -->#x27; in math mode at position 2: m$̲-way $n$-bit mu…" style="color:#cc0000">m$-way $n$-bit multiplexer selects one of its $m</span> <span class="katex-error" title="ParseError: KaTeX parse error: Can&#x27;t use function &#x27;<!-- output_content -->#x27; in math mode at position 2: n$̲-bit inputs, an…" style="color:#cc0000">n$-bit inputs, and outputs it to its $n$-bit output. The selection is specified by a set of $k</span> selection bits, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>m</mi></mrow><annotation encoding="application/x-tex">k = log_2{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">m</span></span></span></span></span>.</p>
<p>Our target computer platform requires two variants of this chip: a $4$-way $16$-bit multiplexer and an $8$-way $16$-bit multiplexer.</p>
<p>API:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Chip name</td>
<td><code>Mux4Way16</code></td>
</tr>
<tr>
<td>Input</td>
<td><code>a[16]</code>, <code>b[16]</code>, <code>c[16]</code>, <code>d[16]</code>, <code>sel[2]</code></td>
</tr>
<tr>
<td>Output</td>
<td><code>out[16]</code></td>
</tr>
<tr>
<td>Function</td>
<td><code>if (sel == 00) then out = a,</code><br><br><code>else if (sel == 01) then out = b,</code><br><br><code>else if (sel == 10) then out = c,</code><br><br><code>else if (sel == 11) then out = d</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Chip name</td>
<td><code>Mux8Way16</code></td>
</tr>
<tr>
<td>Input</td>
<td><code>a[16]</code>, <code>b[16]</code>, <code>c[16]</code>, <code>d[16]</code>, <code>e[16]</code>, <code>f[16]</code>, <code>g[16]</code>, <code>h[16]</code>, <code>sel[3]</code></td>
</tr>
<tr>
<td>Output</td>
<td><code>out[16]</code></td>
</tr>
<tr>
<td>Function</td>
<td><code>if (sel == 000) then out = a,</code><br><br><code>else if (sel == 001) then out = b,</code><br><br><code>else if (sel == 010) then out = c,</code><br><br><code>else if (sel == 011) then out = d</code><br><br><code>else if (sel == 100) then out = e,</code><br><br><code>else if (sel == 101) then out = f,</code><br><br><code>else if (sel == 110) then out = g,</code><br><br><code>else if (sel == 111) then out = h</code></td>
</tr>
</tbody></table>
<p>HDL:</p>
<pre><code class="hljs language-hdl">CHIP Mux4Way16 {

IN a[16], b[16], c[16], d[16], sel[2];

OUT out[16];

PARTS:

// First level: Select between a/b and c/d using sel[0]

Mux16(a=a, b=b, sel=sel[0], out=ab); // ab is the output of first Mux16

Mux16(a=c, b=d, sel=sel[0], out=cd); // cd is the output of second Mux16

  

// Second level: Select between ab and cd using sel[1]

Mux16(a=ab, b=cd, sel=sel[1], out=out);

}
</code></pre><pre><code class="hljs language-hdl">CHIP Mux8Way16 {

IN a[16], b[16], c[16], d[16],

e[16], f[16], g[16], h[16],

sel[3];

OUT out[16];

  

PARTS:

Mux4Way16(a= a, b= b, c= c, d= d, sel= sel[0..1], out= abcd);

Mux4Way16(a= e, b= f, c= g, d= h, sel= sel[0..1], out= efgh);

Mux16(a= abcd, b= efgh, sel= sel[2], out= out);

}
</code></pre><hr>
<p>Finally, we build a <mark>multi-way 16-bit demultiplexer gate</mark>. An <span class="katex-error" title="ParseError: KaTeX parse error: Can&#x27;t use function &#x27;<!-- output_content -->#x27; in math mode at position 2: m$̲-way $n$-bit de…" style="color:#cc0000">m$-way $n$-bit demultiplexer routes its single $n$-bit input to one of its $m</span> <span class="katex-error" title="ParseError: KaTeX parse error: Can&#x27;t use function &#x27;<!-- output_content -->#x27; in math mode at position 2: n$̲-bit outputs. T…" style="color:#cc0000">n$-bit outputs. The other outputs are set to `0`. The selection is specified by a set of $k</span> selection bits, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>m</mi></mrow><annotation encoding="application/x-tex">k = log_2{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">m</span></span></span></span></span>.</p>
<p>Our target computer platform requires two variants of this chip: a $4$-way $1$-bit demultiplexer and an $8$-way $1$-bit demultiplexer.</p>
<p>API:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Chip name</td>
<td><code>DMux4Way</code></td>
</tr>
<tr>
<td>Input</td>
<td><code>in</code>, <code>sel[2]</code></td>
</tr>
<tr>
<td>Output</td>
<td><code>a</code>, <code>b</code>, <code>c</code>, <code>d</code></td>
</tr>
<tr>
<td>Function</td>
<td><code>if (sel == 00) then {a, b, c, d} = {in, 0, 0, 0},</code><br><br><code>else if (sel == 01) then {a, b, c, d} = {0, in, 0, 0},</code><br><br><code>else if (sel == 10) then {a, b, c, d} = {0, 0, in, 0},</code><br><br><code>else if (sel == 11) then {a, b, c, d} = {0, 0, 0, in}</code></td>
</tr>
</tbody></table>
<p>HDL:</p>
<pre><code class="hljs language-hdl">CHIP DMux4Way {

IN in, sel[2];

OUT a, b, c, d;

  

PARTS:

DMux(in= in, sel= sel[1], a= first, b= second);

DMux(in= first, sel= sel[0], a= a, b= b);

DMux(in= second, sel= sel[0], a= c, b= d);

}
</code></pre><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Chip name</td>
<td><code>DMux8Way</code></td>
</tr>
<tr>
<td>Input</td>
<td><code>in</code>, <code>sel[3]</code></td>
</tr>
<tr>
<td>Output</td>
<td><code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code>, <code>f</code>, <code>g</code>, <code>h</code></td>
</tr>
<tr>
<td>Function</td>
<td><code>if (sel == 000) then {a, b, c, …, h} = {1, 0, 0, 0, 0, 0, 0, 0},</code><br><br><code>else if (sel == 001) then {a, b, c, …, h} = {0, 1, 0, 0, 0, 0, 0, 0},</code><br><br><code>if (sel == 010) then {a, b, c, …, h} = {0, 0, 1, 0, 0, 0, 0, 0},</code><br><br>…<br><br><code>if (sel == 111) then {a, b, c, …, h} = {0, 0, 0, 0, 0, 0, 0, 1}</code></td>
</tr>
</tbody></table>
<p>HDL:</p>
<pre><code class="hljs language-hdl">CHIP DMux8Way {

IN in, sel[3];

OUT a, b, c, d, e, f, g, h;

  

PARTS:

DMux(in= in, sel= sel[2], a= first, b= second);

DMux4Way(in= first, sel= sel[0..1], a= a, b= b, c= c, d= d);

DMux4Way(in= second, sel= sel[0..1], a= e, b= f, c= g, d= h);

}
</code></pre><h2>Chapter 2: Boolean arithmetic</h2>
<p>🎯 Objective: Use the gates from chapter 1 to build an ALU (Arithmetic logic unit).</p>
<p>The ALU is the centerpiece chip that executes all the arithmetic and logical operations performed by the computer.</p>
<hr>
<p>A <mark>binary number</mark> is a number expressed in the <strong>base-2 positional numeral system</strong>. Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>x</mi><mi>n</mi></msub><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x = x_{n}x_{n − 1}x_{n − 2} ... x_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> be a string of binary digits, the value of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> in the base-2 positional numeral system is defined as:<br>$<br>x = \sum_{i=0}^{n} x_i \cdot b^i<br>$</p>
<p>e.g.    </p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10010</mn><msub><mn>1</mn><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">100101_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord">10010</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><msup><mn>2</mn><mn>5</mn></msup><mo stretchy="false">]</mo><mo>+</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>×</mo><msup><mn>2</mn><mn>4</mn></msup><mo stretchy="false">]</mo><mo>+</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>×</mo><msup><mn>2</mn><mn>3</mn></msup><mo stretchy="false">]</mo><mo>+</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><msup><mn>2</mn><mn>2</mn></msup><mo stretchy="false">]</mo><mo>+</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>×</mo><msup><mn>2</mn><mn>1</mn></msup><mo stretchy="false">]</mo><mo>+</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><msup><mn>2</mn><mn>0</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[ ( 1 ) × 2^5 ] + [ ( 0 ) × 2^4 ] + [ ( 0 ) × 2^3 ] + [ ( 1 ) × 2^2 ] + [ ( 0 ) × 2^1 ] + [ ( 1 ) × 2^0 ]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10010</mn><msub><mn>1</mn><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">100101_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord">10010</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>×</mo><mn>32</mn><mo stretchy="false">]</mo><mo>+</mo><mo stretchy="false">[</mo><mn>0</mn><mo>×</mo><mn>16</mn><mo stretchy="false">]</mo><mo>+</mo><mo stretchy="false">[</mo><mn>0</mn><mo>×</mo><mn>8</mn><mo stretchy="false">]</mo><mo>+</mo><mo stretchy="false">[</mo><mn>1</mn><mo>×</mo><mn>4</mn><mo stretchy="false">]</mo><mo>+</mo><mo stretchy="false">[</mo><mn>0</mn><mo>×</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mo stretchy="false">[</mo><mn>1</mn><mo>×</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[ 1 × 32 ] + [ 0 × 16 ] + [ 0 × 8 ] + [ 1 × 4 ] + [ 0 × 2 ] + [ 1 × 1 ]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">32</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">16</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">8</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10010</mn><msub><mn>1</mn><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">100101_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord">10010</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><msub><mn>7</mn><mn>10</mn></msub></mrow><annotation encoding="application/x-tex">37_{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord">3</span><span class="mord"><span class="mord">7</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>A <strong>numeral system</strong> is a mathematical notation for representing numbers of a given set using digits or other symbols in a consistent manner.</p>
<p>In a <strong>positional numeral system</strong>, the <strong>radix</strong> or <strong>base</strong> is the number of unique digits, including the digit zero, used to represent numbers.</p>
<p>Computers represent numbers in binary. Any number can be represented by a sequence of bits (binary digits), which in turn may be represented by any mechanism capable of being in two mutually exclusive states.</p>
<p>Integer numbers are unbounded: for any given number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>, there are integers that are less than <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> and integers greater than <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>. However, computers are finite machines that use a fixed word size for representing numbers. An 8-bit register can represent <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup><mo>=</mo><mn>256</mn></mrow><annotation encoding="application/x-tex">2^8 = 256</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">256</span></span></span></span> different things. Using <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> bits, we can represent all the nonnegative integers ranging from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>.</p>
<hr>
<p>The three common methods of extending the binary numeral system to represent <mark>signed numbers</mark> (i.e. positive, negative, and zero numbers) numbers are:</p>
<ul>
<li>Sign–magnitude,</li>
<li>Ones&#39; complement, and</li>
<li>Two&#39;s complement.</li>
</ul>
<p>Of the three, two’s complement is the most commonly used today.</p>
<hr>
<p>A <mark>two&#39;s complement number system</mark> encodes positive and negative numbers in a binary number representation. The weight of each bit is a power of two, except for the <strong>most significant bit</strong> (aka <strong>sign bit</strong>), whose weight is the negative of the corresponding power of two. The value <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> of an <span class="katex-error" title="ParseError: KaTeX parse error: Can&#x27;t use function &#x27;<!-- output_content -->#x27; in math mode at position 2: N$̲-bit integer $a…" style="color:#cc0000">N$-bit integer $a_{N-1} a_{N-2} ... a_0</span> is given by the following formula:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>w</mi><mo>=</mo><mo>−</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msub><msup><mn>2</mn><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>N</mi><mo>−</mo><mn>2</mn></mrow></munderover><msub><mi>a</mi><mi>i</mi></msub><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">w = -(a_{N-1} 2^{N-1}) + \sum_{i=0}^{N-2} a_i 2^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1413em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:3.106em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8747em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span></span>
<p>The two&#39;s complement of an <span class="katex-error" title="ParseError: KaTeX parse error: Can&#x27;t use function &#x27;<!-- output_content -->#x27; in math mode at position 2: N$̲-bit number is …" style="color:#cc0000">N$-bit number is the complement of that number with respect to $2^N</span> (this is the property that gives this system its name). i.e. Given that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> is an <span class="katex-error" title="ParseError: KaTeX parse error: Can&#x27;t use function &#x27;<!-- output_content -->#x27; in math mode at position 2: N$̲-bit number and…" style="color:#cc0000">N$-bit number and $y</span> is its two&#39;s complement, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>=</mo><msup><mn>2</mn><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">x + y = 2^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span>. e.g.</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>N</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">N = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span></span>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mn>2</mn><mi>N</mi></msup><mo>=</mo><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><msub><mn>8</mn><mn>10</mn></msub><mo>=</mo><mn>100</mn><msub><mn>0</mn><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">2^N = 2^3 = 8_{10} = 1000_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord">100</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>I</mi><mi>f</mi><mtext> </mtext><mi>x</mi><mo>=</mo><mn>01</mn><msub><mn>1</mn><mn>2</mn></msub><mtext> </mtext><mo stretchy="false">(</mo><msub><mn>3</mn><mn>10</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">If \space x = 011_2 \space (3_{10})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">01</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mopen">(</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>
<p>Then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> ($x<!-- output_content -->#39;s two&#39;s complement) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mn>10</mn><msub><mn>1</mn><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">= 101_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord">10</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mn>5</mn><mn>10</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(5_{10})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> because:
$
011_2 + 101_2 = 1000_2 = 2^N
$</p>
<hr>
<p><mark>Calculation of the two&#39;s complement of a number</mark> essentially means subtracting the number from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">2^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span>. But as can be seen from the 3-bit example above with the 4-bit <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><msub><mn>0</mn><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">1000_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord">100</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, the number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">2^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span> will not itself be representable in a system limited to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> bits, as it is just outside the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> bit space. Because of this, systems with maximally $N$-bit must break the subtraction into two operations:</p>
<ol>
<li>First, subtract from the maximum number in the <span class="katex-error" title="ParseError: KaTeX parse error: Can&#x27;t use function &#x27;<!-- output_content -->#x27; in math mode at position 2: N$̲-bit system, th…" style="color:#cc0000">N$-bit system, that is $2^N - 1</span>. This term in binary is actually a simple number consisting of &#39;all 1s&#39;, and a subtraction from it can be done by simply inverting all bits in the number. The number obtained in this step is called the <strong>ones&#39; complement</strong> because summing it with the original number yields &#39;all 1s&#39;.</li>
<li>Secondly, add one to the result.</li>
</ol>
<table>
<thead>
<tr>
<th>Bits</th>
<th>Unsigned value</th>
<th>Signed value (Two&#39;s complement)</th>
</tr>
</thead>
<tbody><tr>
<td>000</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>001</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>010</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>011</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>100</td>
<td>4</td>
<td>-4</td>
</tr>
<tr>
<td>101</td>
<td>5</td>
<td>-3</td>
</tr>
<tr>
<td>110</td>
<td>6</td>
<td>-2</td>
</tr>
<tr>
<td>111</td>
<td>7</td>
<td>-1</td>
</tr>
</tbody></table>
<hr>
<p>Here is <mark>why the two&#39;s complement system works</mark>. Given a set of all possible <span class="katex-error" title="ParseError: KaTeX parse error: Can&#x27;t use function &#x27;<!-- output_content -->#x27; in math mode at position 2: N$̲-bit values, we…" style="color:#cc0000">N$-bit values, we can assign the lower (by the binary value) half to be the integers from $0</span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mn>2</mn><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2^{N-1} - 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> inclusive and the upper half to be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">-2^{N-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9247em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> inclusive. The upper half (again, by the binary value) can be used to represent negative integers from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">-2^{N-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9247em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> because, under addition modulo <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">2^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span> they behave the same way as those negative integers. That is to say that, because <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mi>j</mi><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><msup><mn>2</mn><mi>N</mi></msup><mo>=</mo><mi>i</mi><mo>+</mo><mo stretchy="false">(</mo><mi>j</mi><mo>+</mo><msup><mn>2</mn><mi>N</mi></msup><mo stretchy="false">)</mo><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><msup><mn>2</mn><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">i + j \bmod 2^N = i + (j + 2^N) \bmod 2^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span>, any value in the set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>j</mi><mo>+</mo><mi>k</mi><msup><mn>2</mn><mi>N</mi></msup><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><mi>k</mi><mtext> </mtext><mi>i</mi><mi>s</mi><mtext> </mtext><mi>a</mi><mi>n</mi><mtext> </mtext><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>g</mi><mi>e</mi><mi>r</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{j + k2^N \space | \space k \space is \space an \space integer\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord">∣</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace"> </span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mspace"> </span><span class="mord mathnormal">an</span><span class="mspace"> </span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mclose">}</span></span></span></span> can be used in place of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>. Fundamentally, the system counts negative numbers by counting backwards and wrapping around.</p>
<p>Given <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>N</mi></msup><mo>=</mo><msup><mn>2</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">2^N = 2^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>, these are some examples:</p>
<table>
<thead>
<tr>
<th>Addition in the two&#39;s complement system</th>
<th>Addition modulo <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">2^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></th>
</tr>
</thead>
<tbody><tr>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>4</mn><mo>+</mo><mn>3</mn><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-4 + 3 = -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> (represented as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> in binary)</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>+</mo><mn>3</mn><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mn>8</mn><mo>=</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">4 + 3 \bmod 8 = 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> (the two&#39;s complement representation of $-1$)</td>
</tr>
<tr>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>3</mn><mo>+</mo><mn>3</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">-3 + 3 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> (represented as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> in binary)</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>+</mo><mn>3</mn><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mn>8</mn><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">5 + 3 \bmod 8 = 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span> (the two&#39;s complement representation of $0$)</td>
</tr>
<tr>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-2 + 3 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> (represented as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> in binary)</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn><mo>+</mo><mn>3</mn><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mn>8</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">6 + 3 \bmod 8 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> (the two&#39;s complement representation of $1$)</td>
</tr>
</tbody></table>
<hr>
<p>The <mark>two&#39;s complement system has the following advantages</mark> over other systems for representing signed numbers:</p>
<ol>
<li>The fundamental arithmetic operations of addition, subtraction, and multiplication are identical to those for unsigned binary numbers (as long as the inputs are represented in the same number of bits as the output, and any overflow beyond those bits are discarded from the result).</li>
<li>It has no representation for negative zero (unlike the ones&#39; complement and sign-magnitude representations).</li>
</ol>
<p>The material implications of these theoretical results are significant:</p>
<ul>
<li>Dedicated hardware is not needed to handle arithmetic with signed numbers.</li>
<li>Subtraction can be treated as adding the complement of the subtrahend. Again, no dedicated hardware required.</li>
</ul>
<hr>
<p>A <mark>pair of binary numbers can be added</mark> bitwise from right to left, using the same decimal addition algorithm learned in elementary school.</p>
<pre><code class="hljs">
1 1 1 1 1 (carried bits )

  0 1 1 0 1 (13_10)

+ 1 0 1 1 1 (23_10)

-------------

1 0 0 1 0 0 (36_10)
</code></pre><p>When adding in the two&#39;s complement system, any extra carry bit is discarded, such that the result and the addends always have the same number of bits. This is effectively the same as applying the modulo operator. For any number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>, computing <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><msup><mn>2</mn><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">x \bmod 2^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span> essentially results in keeping the lowest <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> bits of the number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>. As explained in the two&#39;s complement section, this modulo operation is what makes the two&#39;s complement system work.</p>
<hr>
<p>An <mark>adder</mark> or summer is a digital circuit used in the ALU to perform addition on binary numbers. We saw (from the elementary school style addition) that computer hardware for binary addition of two $n$-bit numbers can be built from logic gates designed to calculate the sum of three bits (pair of bits plus carry bit). These are the following hierarchy of adders that will be built:</p>
<hr>
<p>A <mark>half adder</mark> is designed to add two bits.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Chip name</td>
<td><code>HalfAdder</code></td>
</tr>
<tr>
<td>Input</td>
<td><code>a</code>, <code>b</code></td>
</tr>
<tr>
<td>Output</td>
<td><code>sum</code>, <code>carry</code></td>
</tr>
<tr>
<td>Function</td>
<td><code>sum = LSB of a + b</code><br><br><code>carry = MSB of a + b</code></td>
</tr>
</tbody></table>
<p>An inspection of the truth table reveals that the outputs <code>sum(a, b)</code> and <code>carry(a, b)</code> are identical to those of two simple Boolean functions <code>Xor</code> and <code>And</code> respectively.</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>carry</th>
<th>sum</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<pre><code class="hljs language-hdl">/**
* Computes the sum of two bits.
*/
CHIP HalfAdder {

IN a, b; // 1-bit inputs

OUT sum, // Right bit of a + b

carry; // Left bit of a + b

PARTS:

And(a= a, b= b, out= carry);

Xor(a = a, b = b, out = sum);
}
</code></pre><hr>
<p>A <mark>full adder</mark> is designed to add three bits. Like the half-adder, the full-adder chip outputs two bits that, taken together, represents the addition of the three input bits.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Chip name</td>
<td>FullAdder`</td>
</tr>
<tr>
<td>Input</td>
<td><code>a</code>, <code>b</code>, <code>c</code></td>
</tr>
<tr>
<td>Output</td>
<td><code>sum</code>, <code>carry</code></td>
</tr>
<tr>
<td>Function</td>
<td><code>sum = LSB of a + b + c</code><br><br><code>carry = MSB of a + b + c</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
<th>carry</th>
<th>sum</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>The names <code>Half-adder</code> and <code>Full-adder</code> derive from the implementation detail that a full-adder chip can be realized from two half-adders (and one other basic chip).</p>
<pre><code class="hljs language-hdl">/**
* Computes the sum of three bits.
*/

CHIP FullAdder {

IN a, b, c; // 1-bit inputs

OUT sum, // Right bit of a + b + c

carry; // Left bit of a + b + c

PARTS:

HalfAdder(a= a, b= b, sum= partialSum, carry= partialCarry);

HalfAdder(a= partialSum, b= c, sum= sum, carry= partialCarry2);

Or(a= partialCarry, b= partialCarry2, out= carry);
}
</code></pre><hr>
<p>An <mark>adder</mark> is designed to add two $n$-bit numbers.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Chip name</td>
<td><code>Add16</code></td>
</tr>
<tr>
<td>Input</td>
<td><code>a[16]</code>, <code>b[16]</code></td>
</tr>
<tr>
<td>Output</td>
<td><code>out[16]</code></td>
</tr>
<tr>
<td>Function</td>
<td>Adds two 16-bit numbers.</td>
</tr>
<tr>
<td>Comment</td>
<td>The overflow bit is ignored.</td>
</tr>
</tbody></table>
<p>The addition of two $n$-bit numbers can be done bitwise, from right to left (from LSB pairs to MSB pairs). In each step, the resulting carry bit from the previous step is fed into the addition.</p>
<pre><code class="hljs language-hdl">/**
* 16-bit adder: Adds two 16-bit two&#x27;s complement values.
* The most significant carry bit is ignored.
*/

CHIP Add16 {

IN a[16], b[16];

OUT out[16];

  

PARTS:

FullAdder(a= a[0], b= b[0], c= false, sum= out[0], carry= carry0);

FullAdder(a= a[1], b= b[1], c= carry0, sum= out[1], carry= carry1);

FullAdder(a= a[2], b= b[2], c= carry1, sum= out[2], carry= carry2);

FullAdder(a= a[3], b= b[3], c= carry2, sum= out[3], carry= carry3);

FullAdder(a= a[4], b= b[4], c= carry3, sum= out[4], carry= carry4);

FullAdder(a= a[5], b= b[5], c= carry4, sum= out[5], carry= carry5);

FullAdder(a= a[6], b= b[6], c= carry5, sum= out[6], carry= carry6);

FullAdder(a= a[7], b= b[7], c= carry6, sum= out[7], carry= carry7);

FullAdder(a= a[8], b= b[8], c= carry7, sum= out[8], carry= carry8);

FullAdder(a= a[9], b= b[9], c= carry8, sum= out[9], carry= carry9);

FullAdder(a= a[10], b= b[10], c= carry9, sum= out[10], carry= carry10);

FullAdder(a= a[11], b= b[11], c= carry10, sum= out[11], carry= carry11);

FullAdder(a= a[12], b= b[12], c= carry11, sum= out[12], carry= carry12);

FullAdder(a= a[13], b= b[13], c= carry12, sum= out[13], carry= carry13);

FullAdder(a= a[14], b= b[14], c= carry13, sum= out[14], carry= carry14);

FullAdder(a= a[15], b= b[15], c= carry14, sum= out[15], carry= carry15);
}
</code></pre><hr>
<p>An <mark>Incrementer</mark> is designed to add <code>1</code> to a given number. Although, the <code>x + 1</code> operation can be realized with the general-purpose <code>Adder</code> chip, a dedicated <code>Incrementer</code> chip can do it more efficiently.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Chip name</td>
<td><code>Inc16</code></td>
</tr>
<tr>
<td>Input</td>
<td><code>in[16]</code></td>
</tr>
<tr>
<td>Output</td>
<td><code>out[16]</code></td>
</tr>
<tr>
<td>Function</td>
<td><code>out = in + 1</code></td>
</tr>
<tr>
<td>Comment</td>
<td>The overflow bit is ignored.</td>
</tr>
</tbody></table>
<pre><code class="hljs language-hdl">/**
* 16-bit incrementer:
* out = in + 1
*/

CHIP Inc16 {

IN in[16];

OUT out[16];

PARTS:

Add16(a = in, b[0] = true, b[1..15] = false, out = out);

}
</code></pre><hr>
<p>The <mark>Arithmetic logic unit (ALU)</mark> is a chip designed to compute a set of arithmetic and logic operations. Unlike the generic chips discussed so far, the ALU described below is specific to the Hack computer:</p>
<ul>
<li>It only performs integer arithmetic (and not, for example, floating point arithmetic)</li>
<li>It computes only a set of 18 arithmetic-logical functions.</li>
</ul>
<table>
<thead>
<tr>
<th>x</th>
<th>y</th>
<th>zx</th>
<th>nx</th>
<th>zy</th>
<th>ny</th>
<th>f</th>
<th>no</th>
<th>out</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>y</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0 (constant zero)</td>
</tr>
<tr>
<td>1</td>
<td>y</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1 (constant one)</td>
</tr>
<tr>
<td>-1</td>
<td>y</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>-1</td>
<td>-1 (constant minus one)</td>
</tr>
<tr>
<td>x</td>
<td>y</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>x</td>
<td>x</td>
</tr>
<tr>
<td>x</td>
<td>y</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>y</td>
<td>y</td>
</tr>
<tr>
<td>x</td>
<td>y</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>¬x</td>
<td>NOT x</td>
</tr>
<tr>
<td>x</td>
<td>y</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>¬y</td>
<td>NOT y</td>
</tr>
<tr>
<td>x</td>
<td>y</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>-x</td>
<td>-x</td>
</tr>
<tr>
<td>x</td>
<td>y</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>-y</td>
<td>-y</td>
</tr>
<tr>
<td>x</td>
<td>y</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>x+1</td>
<td>x + 1</td>
</tr>
<tr>
<td>x</td>
<td>y</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>y+1</td>
<td>y + 1</td>
</tr>
<tr>
<td>x</td>
<td>y</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>x-1</td>
<td>x - 1</td>
</tr>
<tr>
<td>x</td>
<td>y</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>y-1</td>
<td>y - 1</td>
</tr>
<tr>
<td>x</td>
<td>y</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>x+y</td>
<td>x + y</td>
</tr>
<tr>
<td>x</td>
<td>y</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>x-y</td>
<td>x - y</td>
</tr>
<tr>
<td>x</td>
<td>y</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>y-x</td>
<td>y - x</td>
</tr>
<tr>
<td>x</td>
<td>y</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>x&amp;y</td>
<td>x AND y</td>
</tr>
<tr>
<td>x</td>
<td>y</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>x|y</td>
<td>x OR y</td>
</tr>
</tbody></table>
<p>The Hack ALU operates on two $16$-bit two&#39;s complement integers denoted <code>x</code> and <code>y</code>, an on six $1$-bit inputs, called <strong>control bits</strong>. The control bits &quot;tell&quot; the ALU which function to compute. Each control bit effects a standalone conditional micro-action:</p>
<pre><code class="hljs">1. if (zx) then x = 0 else x = x

2. if (nx) then x = !x else x = x

3. if (zy) then y = 0 else y = y

4. if (ny) then y = !y else y = y

5. if (f) then out = x + y else out = x and y

6. if (no) then out = !out else out = out
</code></pre><blockquote>
<p>It may be instructive to describe the thought process that led to the design of this particular ALU. First, we made a list of all the primitive operations that we wanted our computer to be able to perform. Next, we used backward reasoning to figure out how x, y, and out can be manipulated in binary fashion in order to carry out the desired operations. These processing requirements, along with our objective to keep the ALU logic as simple as possible, have led to the design decision to use six control bits, each associated with a straightforward binary operation.</p>
</blockquote>
<pre><code class="hljs language-hdl">/**

* ALU (Arithmetic Logic Unit):

* Computes out = one of the following functions:

* 0, 1, -1,

* x, y, !x, !y, -x, -y,

* x + 1, y + 1, x - 1, y - 1,

* x + y, x - y, y - x,

* x &amp; y, x | y

* on the 16-bit inputs x, y,

* according to the input bits zx, nx, zy, ny, f, no.

* In addition, computes the two output bits:

* if (out == 0) zr = 1, else zr = 0

* if (out &lt; 0) ng = 1, else ng = 0

*/

// Implementation: Manipulates the x and y inputs

// and operates on the resulting values, as follows:

// if (zx == 1) sets x = 0 // 16-bit constant

// if (nx == 1) sets x = !x // bitwise not

// if (zy == 1) sets y = 0 // 16-bit constant

// if (ny == 1) sets y = !y // bitwise not

// if (f == 1) sets out = x + y // integer 2&#x27;s complement addition

// if (f == 0) sets out = x &amp; y // bitwise and

// if (no == 1) sets out = !out // bitwise not


CHIP ALU {

IN

x[16], y[16], // 16-bit inputs

zx, // zero the x input?

nx, // negate the x input?

zy, // zero the y input?

ny, // negate the y input?

f, // compute (out = x + y) or (out = x &amp; y)?

no; // negate the out output?

OUT

out[16], // 16-bit output

zr, // if (out == 0) equals 1, else 0

ng; // if (out &lt; 0) equals 1, else 0

  

PARTS:

// x&#x27;s pre-processing

Mux16(a= x, sel= zx, out= x1);

Not16(in= x1, out= x1Negated);

Mux16(a= x1, b= x1Negated, sel= nx, out= x2);

  

// y&#x27;s pre-processing

Mux16(a= y, sel= zy, out= y1);

Not16(in= y1, out= y1Negated);

Mux16(a= y1, b= y1Negated, sel= ny, out= y2);

  

// function

Add16(a = x2, b = y2, out = summed);

And16(a = x2, b = y2, out = andded);

Mux16(a= andded, b= summed, sel= f, out= out1);

  

// output post-processing

Not16(in= out1, out= out1Negated);

Mux16(a= out1, b= out1Negated, sel= no, out= out, out[15]= outFirst, out[0..7]= outLeft, out[8..15]= outRight);

  

// ng status bit

And(a= true, b= outFirst, out=ng);

  

// zr status bit

Or8Way(in= outLeft, out= zrLeft);

Or8Way(in= outRight, out= zrRight);

Or(a= zrLeft, b= zrRight, out= zrLeftOrZrRight);

Not(in= zrLeftOrZrRight, out= zr);

}
</code></pre><h2>Chapter 3: Memory</h2>
<p>There are two types of chips:</p>
<ol>
<li><mark>Combinational chips</mark> compute functions that depend solely on combinations of their input values. They cannot maintain state. All the chips built thus far are combinational chips.</li>
<li><mark>Sequential chips</mark> compute functions that depend on both their input values and their previous state. They have &quot;memory&quot; and can preserve data over time.</li>
</ol>
<hr>
<p>A <mark>flip-flop</mark> is a basic building block of sequential chips. It has two stable states and can be used to store state information.</p>
<p>A flip-flop encapsulates the intricate art of synchronization, clocking, and feedback loops that are essential for building sequential chips.</p>
<p>Using these flip-flops as elementary building blocks, we will specify and build all the memory devices employed by a typical modern computer: registers, RAMs, and counters.</p>
<p>This effort will complete the construction of the chip set needed to build an entire computer.</p>
<hr>
<p>The act of &quot;remembering something&quot; is inherently time-dependent: You remember now what has been committed to memory before.
Thus, in order to build chips that &quot;remember&quot; information, we must first develop some standard means for representing the progression of time.</p>
<p>In most computers, the progression of time is regulated by a <mark>clock signal</mark>. This signal oscillates between two values, <code>0</code> (called low/tick) and <code>1</code> (called high/tock), at a regular pace.</p>
<p>The clock hardware implementation is usually an oscillator that generates a square wave. The frequency of the clock signal is measured in <strong>Hertz</strong> (Hz), which is the number of oscillations per second.</p>
<p><img src="assets/nand-images/hertz.webp" alt="Clock signal">
<em><a href="https://www.xtronical.com/6502computerep3/">Image source</a></em></p>
<p>The elapsed time between the beginning of a &quot;tick&quot; and the end of a subsequent &quot;tock&quot; is called a <strong>clock cycle</strong>.</p>
<p>The clock is used to synchronize the sequential chips. Using the hardware’s circuitry, this signal is simultaneously broadcast to every sequential chip throughout the computer platform.</p>
<hr>
<p>There are several variants of a flip-flop. We use a variant called the <mark>data flip-flop (DFF)</mark>.</p>
<p>A DFF is a simple memory element that stores a single bit. It has a data input <code>in</code>, a clock input <code>load</code>, and an output <code>out</code>. When the clock input is <code>1</code>, the flip-flop copies the value of the data input to its output. When the clock input is <code>0</code>, the flip-flop holds its previous value.</p>
<p>Taken together, both inputs enables the DFF to implement the behavior <code>out(t) = in(t-1)</code>, where <code>t</code> is the current clock cycle. In other words, the DFF outputs the input value from the previous clock cycle.</p>
<p><img src="assets/nand-images/dff.png" alt="DFF"></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Chip name</td>
<td><code>DFF</code></td>
</tr>
<tr>
<td>Input</td>
<td><code>in</code>, <code>load</code></td>
</tr>
<tr>
<td>Output</td>
<td><code>out</code></td>
</tr>
<tr>
<td>Function</td>
<td><code>out(t) = in(t-1)</code></td>
</tr>
<tr>
<td>Comment</td>
<td>This clocked gate has a built-in implementation and thus there is no need to implement it.</td>
</tr>
</tbody></table>
<hr>
<blockquote>
<p>[...] When the clock input is <code>1</code>, the flip-flop copies the value of the data input to its output. When the clock input is <code>0</code>, the flip-flop holds its previous value.</p>
</blockquote>
<p>Actually, what we described previously is a latch: which is level-triggered.</p>
<p>A DFF is edge-triggered. Our DFF will be rising edge-triggered, meaning it only copies the <code>in</code> data input when the clock signal transitions from <code>0</code> to <code>1</code>.</p>
<p>All DFFs in a computer are connected to the same clock signal.</p>
<hr>
<p>This reliable and predictable behavior of DFFs is crucial for data synchronization across the computer platform. There are physical delays in the propagation of signals through the computer’s hardware, e.g. It takes some time for the input into the ALU to stabilize and for the ALU to compute its output.</p>
<p>We solve this problem by using <mark>discrete time</mark>:</p>
<ul>
<li>First, the <code>cycle length</code> must be set to a value slightly greater than the <code>maximum propagation delay</code> in the computer</li>
<li>Secondly, we can ONLY use the chip&#39;s output at end of cycles, and ignore all the fluctuations that can occur within cycles. This is achieved by simply using a DFF (because it&#39;s edge-triggered) to store the output of the chip. In our ALU example, the output of the ALU is stored in a register, which ignores the unstable output of the ALU due to propagation delays.</li>
</ul>
<p><img src="assets/nand-images/dff_sync.png" alt="Discrete time"></p>
<hr>
<p>A <mark>register</mark> is a storage device that can &quot;store&quot; or &quot;remember&quot; a value over time, implementing the classical storage behavior <code>out = out(t-1)</code>.</p>
<p>A DFF, on the other hand, can only output its previous input, namely, <code>out = in(t-1)</code>. We can build a register from a DFF, however, we must consider the following:</p>
<ol>
<li>The rules of chip design dictate that internal pins must have a fan-in of 1, meaning that they can be fed from a single source only.</li>
<li>We need to be able to specify when to read from the DFF and when to write to it.</li>
</ol>
<p>A natural way to build our register is to use a multiplexor: the &quot;select bit&quot; of the multiplexor becomes the &quot;load bit&quot; of the overall register chip:</p>
<blockquote>
<p>If we want the register to start storing a new value, we can put this value in the <code>in</code> input and set the load bit to <code>1</code>; if we want the register to keep storing its internal value until further notice, we can set the load bit to <code>0</code>.</p>
</blockquote>
<p><img src="assets/nand-images/register.png" alt="Register"></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Chip name</td>
<td><code>Bit</code> or <code>Binary cell</code> (Single bit register)</td>
</tr>
<tr>
<td>Input</td>
<td><code>in</code>, <code>load</code></td>
</tr>
<tr>
<td>Output</td>
<td><code>out</code></td>
</tr>
<tr>
<td>Function</td>
<td><code>if (load(t-1) == 1) out(t) = in(t-1) else out(t) = out(t-1)</code></td>
</tr>
</tbody></table>
<pre><code class="hljs language-hdl">CHIP Bit {
    IN in, load;
    OUT out;

    PARTS:
    DFF(in= dffIn, out= dffOut, out= out);
    Mux(a= dffOut, b= in, sel= load, out= dffIn);
}
</code></pre><p>A multi-bit register of <strong>width</strong> <code>w</code> can be constructed from an array of <code>w</code> 1-bit registers. The basic design parameter of such a register is its width — the number of bits that it holds — e.g., <code>16</code>, <code>32</code>, or <code>64</code>.
The multi-bit contents of such registers are typically referred to as <strong>words</strong>.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Chip name</td>
<td><code>Register</code></td>
</tr>
<tr>
<td>Input</td>
<td><code>in[16]</code>, <code>load</code></td>
</tr>
<tr>
<td>Output</td>
<td><code>out[16]</code></td>
</tr>
<tr>
<td>Function</td>
<td><code>if (load(t-1) == 1) out(t) = in(t-1) else out(t) = out(t-1)</code></td>
</tr>
</tbody></table>
<pre><code class="hljs language-hdl">CHIP Register {
    IN in[16], load;
    OUT out[16];

    PARTS:
    Bit(in= in[0], load= load, out= out[0]);
    Bit(in= in[1], load= load, out= out[1]);
    Bit(in= in[2], load= load, out= out[2]);
    Bit(in= in[3], load= load, out= out[3]);
    Bit(in= in[4], load= load, out= out[4]);
    Bit(in= in[5], load= load, out= out[5]);
    Bit(in= in[6], load= load, out= out[6]);
    Bit(in= in[7], load= load, out= out[7]);
    Bit(in= in[8], load= load, out= out[8]);
    Bit(in= in[9], load= load, out= out[9]);
    Bit(in= in[10], load= load, out= out[10]);
    Bit(in= in[11], load= load, out= out[11]);
    Bit(in= in[12], load= load, out= out[12]);
    Bit(in= in[13], load= load, out= out[13]);
    Bit(in= in[14], load= load, out= out[14]);
    Bit(in= in[15], load= load, out= out[15]);
}
</code></pre><hr>
<p>A <mark>RAM chip</mark> (aka direct access memory unit) is a sequential chip that can store multiple data words. Each word is stored in a register, and the registers are indexed by an address.</p>
<p><img src="assets/nand-images/ram.png" alt="RAM"></p>
<p>The term random access memory derives from the requirement that any randomly chosen word in the memory — irrespective of its physical location — be accessed directly, in equal speed.</p>
<p>This requirement can be satisfied as follows:</p>
<ul>
<li>First, we assign each word in the <code>n</code>-register RAM a unique address (an integer between <code>0</code> to <code>n-1</code>), according to which it will be accessed.</li>
<li>Second, in addition to building an array of <code>n</code> registers, we build a gate logic design that, given an address <code>j</code>, is capable of selecting the individual register whose address is <code>j</code>.</li>
</ul>
<blockquote>
<p>In sum, a classical RAM device accepts three inputs: a data input, an address input, and a load bit.
The address specifies which RAM register should be accessed in the current time unit.</p>
<p>In the case of a read operation (<code>load=0</code>), the RAM’s output immediately emits the value of the selected register.</p>
<p>In the case of a write operation (<code>load=1</code>), the selected memory register commits to the input value in the next time unit, at which point the RAM’s output will start emitting it.</p>
</blockquote>
<p>The basic design parameters of a RAM device are:</p>
<ol>
<li>Its data <code>width</code> — the width of each one of its words, and</li>
<li>Its size — the number of words in the RAM.</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Chip name</td>
<td><code>RAMn</code></td>
</tr>
<tr>
<td>Input</td>
<td><code>in[16]</code>, <code>address[k]</code>, <code>load</code></td>
</tr>
<tr>
<td>Output</td>
<td><code>out[16]</code></td>
</tr>
<tr>
<td>Function</td>
<td><code>out(t) = RAM[address(t)](t)</code><br/> <code>if (load(t-1) == 1) then RAM[address(t-1)](t) = in(t-1)</code></td>
</tr>
<tr>
<td>Comment</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">k = log_2{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">n</span></span></span></span></span> and we will build <code>RAM8</code>( <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">n=8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span> ),<code>RAM64</code>( <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>64</mn></mrow><annotation encoding="application/x-tex">n=64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">64</span></span></span></span> ),<code>RAM512</code>( <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>512</mn></mrow><annotation encoding="application/x-tex">n=512</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">512</span></span></span></span> ),<code>RAM4K</code>( <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>4096</mn></mrow><annotation encoding="application/x-tex">n=4096</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4096</span></span></span></span> ),<code>RAM16K</code>( <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>16384</mn></mrow><annotation encoding="application/x-tex">n=16384</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16384</span></span></span></span> ),</td>
</tr>
</tbody></table>
<pre><code class="hljs language-hdl">CHIP RAM8 {
    IN in[16], load, address[3];
    OUT out[16];

    PARTS:
    CHIP RAM8 {
    IN in[16], load, address[3];
    OUT out[16];

    PARTS:
    DMux8Way(in= load, sel= address, a= loadA, b= loadB, c= loadC, d= loadD, e= loadE, f= loadF, g= loadG, h= loadH);
    Register(in= in, load= loadA, out= out1);
    Register(in= in, load= loadB, out= out2);
    Register(in= in, load= loadC, out= out3);
    Register(in= in, load= loadD, out= out4);
    Register(in= in, load= loadE, out= out5);
    Register(in= in, load= loadF, out= out6);
    Register(in= in, load= loadG, out= out7);
    Register(in= in, load= loadH, out= out8);
    Mux8Way16(a= out1, b= out2, c= out3, d= out4, e= out5, f= out6, g= out7, h= out8, sel= address, out= out);
}
}
</code></pre><pre><code class="hljs language-hdl">CHIP RAM64 {
    IN in[16], load, address[6];
    OUT out[16];

    PARTS:
    DMux8Way(in= load, sel= address[3..5], a= load1, b= load2, c= load3, d= load4, e= load5, f= load6, g= load7, h= load8);
    RAM8(in= in, load= load1, address= address[0..2], out= out1);
    RAM8(in= in, load= load2, address= address[0..2], out= out2);
    RAM8(in= in, load= load3, address= address[0..2], out= out3);
    RAM8(in= in, load= load4, address= address[0..2], out= out4);
    RAM8(in= in, load= load5, address= address[0..2], out= out5);
    RAM8(in= in, load= load6, address= address[0..2], out= out6);
    RAM8(in= in, load= load7, address= address[0..2], out= out7);
    RAM8(in= in, load= load8, address= address[0..2], out= out8);
    Mux8Way16(a= out1, b= out2, c= out3, d= out4, e= out5, f= out6, g= out7, h= out8, sel= address[3..5], out= out);
}
</code></pre><pre><code class="hljs language-hdl">CHIP RAM512 {
    IN in[16], load, address[9];
    OUT out[16];

    PARTS:
    DMux8Way(in= load, sel= address[6..8], a= load1, b= load2, c= load3, d= load4, e= load5, f= load6, g= load7, h= load8);
    RAM64(in= in, load= load1, address= address[0..5], out= out1);
    RAM64(in= in, load= load2, address= address[0..5], out= out2);
    RAM64(in= in, load= load3, address= address[0..5], out= out3);
    RAM64(in= in, load= load4, address= address[0..5], out= out4);
    RAM64(in= in, load= load5, address= address[0..5], out= out5);
    RAM64(in= in, load= load6, address= address[0..5], out= out6);
    RAM64(in= in, load= load7, address= address[0..5], out= out7);
    RAM64(in= in, load= load8, address= address[0..5], out= out8);
    Mux8Way16(a= out1, b= out2, c= out3, d= out4, e= out5, f= out6, g= out7, h= out8, sel= address[6..8], out= out);

}
</code></pre><pre><code class="hljs language-hdl">CHIP RAM4K {
    IN in[16], load, address[12];
    OUT out[16];

    PARTS:
    DMux8Way(in= load, sel= address[9..11], a= load1, b= load2, c= load3, d= load4, e= load5, f= load6, g= load7, h= load8);
    RAM512(in= in, load= load1, address= address[0..8], out= out1);
    RAM512(in= in, load= load2, address= address[0..8], out= out2);
    RAM512(in= in, load= load3, address= address[0..8], out= out3);
    RAM512(in= in, load= load4, address= address[0..8], out= out4);
    RAM512(in= in, load= load5, address= address[0..8], out= out5);
    RAM512(in= in, load= load6, address= address[0..8], out= out6);
    RAM512(in= in, load= load7, address= address[0..8], out= out7);
    RAM512(in= in, load= load8, address= address[0..8], out= out8);
    Mux8Way16(a= out1, b= out2, c= out3, d= out4, e= out5, f= out6, g= out7, h= out8, sel= address[9..11], out= out);

}
</code></pre><pre><code class="hljs language-hdl">CHIP RAM16K {
    IN in[16], load, address[14];
    OUT out[16];

    PARTS:
    DMux8Way(in= load, sel= address[11..13], a= load1, b= load2, c= load3, d= load4, e= load5, f= load6, g= load7, h= load8);
    RAM4K(in= in, load= load1, address= address[0..11], out= out1);
    RAM4K(in= in, load= load2, address= address[0..11], out= out2);
    RAM4K(in= in, load= load3, address= address[0..11], out= out3);
    RAM4K(in= in, load= load4, address= address[0..11], out= out4);
    RAM4K(in= in, load= load5, address= address[0..11], out= out5);
    RAM4K(in= in, load= load6, address= address[0..11], out= out6);
    RAM4K(in= in, load= load7, address= address[0..11], out= out7);
    RAM4K(in= in, load= load8, address= address[0..11], out= out8);
    Mux8Way16(a= out1, b= out2, c= out3, d= out4, e= out5, f= out6, g= out7, h= out8, sel= address[11..13], out= out);
    
}
</code></pre><hr>
<p>A <mark>counter</mark> is a sequential chip whose state is an integer number that increments every time unit, effecting the function <code>out = out(t - 1) + c</code>, where <code>c</code> is typically <code>1</code>.</p>
<p>A counter chip can be implemented by combining the input/output logic of a standard register with the combinatorial logic for adding a constant.</p>
<p>Typically, the counter will have to be equipped with some additional functionality, such as possibilities for resetting the count to zero, loading a new counting base, or decrementing instead of incrementing.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Chip name</td>
<td><code>Counter</code></td>
</tr>
<tr>
<td>Input</td>
<td><code>in[16]</code>, <code>load</code>, <code>inc</code>, <code>reset</code></td>
</tr>
<tr>
<td>Output</td>
<td><code>out[16]</code></td>
</tr>
<tr>
<td>Function</td>
<td><code>if (reset(t-1) == 1) then out(t) = 0</code><br/> <code>else if (load(t-1) == 1) then out(t) = in(t-1)</code><br/> <code>else if (inc(t-1) == 1) then out(t) = out(t-1) + 1</code><br/> <code>else out(t) = out(t-1)</code></td>
</tr>
</tbody></table>
<pre><code class="hljs language-hdl">CHIP PC {
    IN in[16], reset, load, inc;
    OUT out[16];
    
    PARTS:
    Register(in= inRegister, load= true, out= outRegister, out= out);
    Inc16(in= outRegister, out= outInc);
    Mux16(a= outRegister, b= outInc, sel= inc, out= out1);
    Mux16(a= out1, b= in, sel= load, out= out2);
    Mux16(a= out2, b= false, sel= reset, out= inRegister);
}
</code></pre><hr>
<p>Simply stated, a sequential chip is a chip that embeds one or more DFF gates, either directly or indirectly.</p>
<p><img src="assets/nand-images/combinational_vs_sequential.png" alt="Sequential chip"></p>
<h2>Chapter 4: Machine Language</h2>
<p>A <mark>machine language</mark> is an agreed-upon formalism, designed to code low-level programs as series of machine instructions. The primary goals of a machine language&#39;s design are:</p>
<ol>
<li>Direct execution in, and</li>
<li>Total control of, a given hardware platform.</li>
</ol>
<p>A machine language is the fine line where hardware and software meet: it can be considered as both a programming tool and an integral part of the hardware platform.</p>
<hr>
<p>This chapter only focuses on the machine language and leaves the hardware details to the next chapter. To give a general description of machine languages, it&#39;s sufficient to only use three main hardware abstractions:</p>
<ol>
<li><p><strong>Processor</strong>: The processor, normally called the CPU (Central Processing Unit), is a device capable of performing a fixed set of elementary operations. These typically include:</p>
<ul>
<li>Arithmetic operations (<code>addition</code>, <code>subtraction</code>, <code>multiplication</code>, <code>division</code>)</li>
<li>Logical operations (<code>AND</code>, <code>OR</code>, <code>NOT</code>)</li>
<li>Memory access operations (<code>load</code>, <code>store</code>)</li>
<li>Control/Branching operations (<code>jump</code>, <code>branch</code>). Branching is used to conditional or unconditional jump to selected locations in a program. Branching serves several purposes like: looping, conditional execution, and subroutine calls.</li>
</ul>
<p> The operands of these operations and their results/output are binary values that are read and stored in registers or selected memory locations.</p>
</li>
<li><p><strong>Memory</strong>: The term memory refers loosely to the collection of hardware devices that store data and instructions in a computer.</p>
</li>
<li><p><strong>Set of registers</strong>: Memory access is a relatively slow operation, requiring long instruction formats. For this reason, most processors are equipped with
 several registers, each capable of holding a single value, allowing the processor to manipulate data and instructions quickly.</p>
</li>
</ol>
<hr>
<p>A machine language is a series of coded instructions. For example, an instruction in a 16-bit computer may be <code>1010001100011001</code>.
In order to figure out what this instruction means, we must know the instruction set of the underlying hardware platform.
For example, the language, may be such that each instruction consists of four 4-bit fields: The left-most field codes a CPU operation, and the remaining
three fields code the operation&#39;s operands.</p>
<p>Since binary codes are rather cryptic, machine languages are normally specified using both binary codes and symbolic mnemonics.
A mnemonic is a short, easy-to-remember name for a binary code.
For example, the binary code <code>1010001100011001</code> may be associated with the mnemonic <code>ADD R1, R2, R3</code>.</p>
<p>Hence, a machine language instruction can be specified either directly using binary codes or indirectly using symbolic mnemonics.</p>
<hr>
<p>We can take the symbolic abstraction one step further, and create a programming language that allows the creation of programs using symbolic commands rather than binary instructions.
This programming language is called an <mark>assembly language</mark>. And the symbolic mnemonics are just a component of the assembly language, specifically the symbols that
represent machine instructions.</p>
<hr>
<p>The Hack computer is a von Neumann platform. It&#39;s a simple computer with a $16$-bit architecture which has:</p>
<ol>
<li>A CPU</li>
<li>A <strong>read-only memory (ROM)</strong> that stores the computer instructions. It is <span class="katex-error" title="ParseError: KaTeX parse error: Can&#x27;t use function &#x27;<!-- output_content -->#x27; in math mode at position 3: 16$̲-bit wide and h…" style="color:#cc0000">16$-bit wide and have a $15$-bit address space (i.e. it can hold $32K (2^{15})</span> $16$-bit instructions).</li>
<li>A <strong>random access memory (RAM)</strong> that stores the computer data. It is also $16$-bit wide and have a $15$-bit address space.</li>
<li>Two memory-mapped I/O devices: a screen and a keyboard.</li>
<li>A $16$-bit instruction set.</li>
<li>Two $16$-bit registers called <code>A</code> and <code>D</code>. These registers can be manipulated explicitly by arithmetic and logical instructions (e.g. <code>D=A+1</code>, <code>A=D&amp;A</code>).
The <code>D</code> register is used solely to store data values; while the <code>A</code> register is used to both store data values and memory addresses.
So, depending on the context, the contents of <code>A</code> can be interpreted as:<ul>
<li>A data value</li>
<li>A memory address in the data memory</li>
<li>A memory address in the instruction memory</li>
</ul>
</li>
</ol>
<blockquote>
<p>Why do we overload the <code>A</code> register with so many roles?
Since Hack instructions are 16-bit wide, and since addresses are specified using 15-bits, it&#39;s impossible to pack both an operation code and an address in one instruction.
Thus, the syntax of the Hack language mandates that memory access instructions operate on an implicit memory location labeled <code>M</code>, for example <code>D=M+1</code>.
In order to resolve this address, the convention is that <code>M</code> always refers to the memory word whose address is the current value of the <code>A</code> register.
<strong>That is <code>M</code> is a synonym for <code>RAM[A]</code></strong>. This implies, we must first load the address into the <code>A</code> register before we can access the memory word at that address.</p>
<p>This also applies to instruction memory access. To jump to a specific instruction, we must first load the address of that instruction into the <code>A</code> register.</p>
<p>In a nutshell, the <code>A</code> register&#39;s value is interpreted based on how it is used in subsequent instructions.</p>
<p>An alternative solution would be to have more registers, but this would have increased the complexity of the hardware.</p>
</blockquote>
<hr>
<p>The Hack language consists of two generic instructions:</p>
<ol>
<li>An address instruction (A-instruction) and</li>
<li>A compute instruction (C-instruction).</li>
</ol>
<hr>
<p>The <mark>A-instruction</mark> is used to set the <code>A</code> register to a $15$-bit value:</p>
<p>A-instruction&#39;s symbolic representation: <code>@value</code> (where <code>value</code> is a non-negative decimal number or a symbol referring to such a number).
A-instruction&#39;s binary representation: <code>0value</code> (where <code>value</code> is a $15$-bit binary number).</p>
<p>The leftmost bit is the A-instruction marker bit, which is always set to <code>0</code>.</p>
<p>The A-instruction is used for three different purposes:</p>
<ol>
<li>It provides the only way to enter a constant into the computer under program control.</li>
<li>It sets the stage for a subsequent C-instruction designed to access a specific location in the data memory.</li>
<li>It sets the stage for a subsequent C-instruction designed to jump to a specific location in the instruction memory.</li>
</ol>
<hr>
<p>The <mark>C-instruction</mark> is used to perform a computation. The instruction code is a specification that answers three questions:</p>
<ol>
<li>What to compute?</li>
<li>Where to store the computed value?</li>
<li>What to do next?</li>
</ol>
<p>C-instruction&#39;s symbolic representation: <code>dest=comp;jump</code> (where <code>dest</code> is the destination register, <code>comp</code> is the computation, and <code>jump</code> is the jump condition). Both <code>dest=</code> and <code>;jump</code> are optional.
C-instruction&#39;s binary representation: <code>1 1 1 a c_1 c_2 c_3 c_4 c_5 c_6 d_1 d_2 d_3 j_1 j_2 j_3</code> (where <code>a_n</code> &amp; <code>c_n</code> specify the comp component; <code>d_n</code> specifies the dest component, and <code>j_n</code> specifies the jump component).</p>
<p>The leftmost bit is the C-instruction marker bit, which is always set to <code>1</code>. The next wo bits are not used and are set to <code>1</code>.</p>
<hr>
<p>The <code>dest</code> component of the C-instruction specifies where to store the computed value (the ALU output).</p>
<p>The first and second bits specify whether to store the computed value in the <code>A</code> register and in the <code>D</code> register, respectively.
The third bit specifies whether to store the computed value in the data memory location specified by the <code>A</code> register.</p>
<table>
<thead>
<tr>
<th>d1</th>
<th>d2</th>
<th>d3</th>
<th><strong>dest</strong> mnemonic</th>
<th>Destination (where to store the computed value)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td><code>null</code></td>
<td>Do not store the computed value</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td><code>M</code></td>
<td>Store the computed value in the data memory</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td><code>D</code></td>
<td>Store the computed value in the <code>D</code> register</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td><code>MD</code></td>
<td>Store the computed value in the <code>D</code> register and in the data memory</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td><code>A</code></td>
<td>Store the computed value in the <code>A</code> register</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td><code>AM</code></td>
<td>Store the computed value in the <code>A</code> register and in the data memory</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td><code>AD</code></td>
<td>Store the computed value in the <code>A</code> register and in the <code>D</code> register</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td><code>AMD</code></td>
<td>Store the computed value in the <code>A</code> register, in the <code>D</code> register, and in the data memory</td>
</tr>
</tbody></table>
<hr>
<p>The <code>comp</code> component of the C-instruction specifies what the ALU should compute.
We can compute a fixed set of functions on the <code>D</code>, <code>A</code>, and <code>M</code> registers.
The a-bit specifies whether the <code>A</code> register or the <code>M</code> register should be used as the ALU&#39;s input.
And the six c-bits specifies the function to be computed.
All <span class="katex-error" title="ParseError: KaTeX parse error: Can&#x27;t use function &#x27;<!-- output_content -->#x27; in math mode at position 2: 7$̲-bit comprise t…" style="color:#cc0000">7$-bit comprise the `comp` field. While this $7$-bit field can specify $128</span> different possible operations, only <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>28</mn></mrow><annotation encoding="application/x-tex">28</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">28</span></span></span></span> are used in the Hack language.</p>
<table>
<thead>
<tr>
<th>(when a=0) <strong>comp</strong> mnemonic</th>
<th>c1</th>
<th>c2</th>
<th>c3</th>
<th>c4</th>
<th>c5</th>
<th>c6</th>
<th>(when a=1) <strong>comp</strong> mnemonic</th>
</tr>
</thead>
<tbody><tr>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>0</code></td>
<td></td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td></td>
</tr>
<tr>
<td><code>-1</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>0</code></td>
<td></td>
</tr>
<tr>
<td><code>D</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td></td>
</tr>
<tr>
<td><code>A</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>M</code></td>
</tr>
<tr>
<td><code>!D</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>0</code></td>
<td><code>1</code></td>
<td></td>
</tr>
<tr>
<td><code>!A</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>!M</code></td>
</tr>
<tr>
<td><code>-D</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td></td>
</tr>
<tr>
<td><code>-A</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>-M</code></td>
</tr>
<tr>
<td><code>D+1</code></td>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td></td>
</tr>
<tr>
<td><code>A+1</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>M+1</code></td>
</tr>
<tr>
<td><code>D-1</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>0</code></td>
<td></td>
</tr>
<tr>
<td><code>A-1</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>0</code></td>
<td><code>M-1</code></td>
</tr>
<tr>
<td><code>D+A</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>0</code></td>
<td><code>D+M</code></td>
</tr>
<tr>
<td><code>D-A</code></td>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>D-M</code></td>
</tr>
<tr>
<td><code>A-D</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>M-D</code></td>
</tr>
<tr>
<td><code>D&amp;A</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>D&amp;M</code></td>
</tr>
<tr>
<td><code>D|A</code></td>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>D|M</code></td>
</tr>
</tbody></table>
<hr>
<p>The <code>jump</code> component of the C-instruction specifies a jump condition, namely, which command to fetch and execute next.
Whether a not a jump should actually materialize depends on the three j-bits of the jump component and the ALU&#39;s output value.
It is a <span class="katex-error" title="ParseError: KaTeX parse error: Can&#x27;t use function &#x27;<!-- output_content -->#x27; in math mode at position 2: 3$̲-bit field that…" style="color:#cc0000">3$-bit field that can specify one of $8</span> different jump conditions.</p>
<table>
<thead>
<tr>
<th>j1 (<code>out &lt; 0</code>)</th>
<th>j2 (<code>out = 0</code>)</th>
<th>j3 (<code>out &gt; 0</code>)</th>
<th><strong>jump</strong> mnemonic</th>
<th>Effect</th>
</tr>
</thead>
<tbody><tr>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>null</code></td>
<td>No jump (this is the default, it simply proceeds to the next instruction)</td>
</tr>
<tr>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>JGT</code></td>
<td>Jump if <code>out &gt; 0</code></td>
</tr>
<tr>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>0</code></td>
<td><code>JEQ</code></td>
<td>Jump if <code>out = 0</code></td>
</tr>
<tr>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>JGE</code></td>
<td>Jump if <code>out &gt;= 0</code></td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>0</code></td>
<td><code>0</code></td>
<td><code>JLT</code></td>
<td>Jump if <code>out &lt; 0</code></td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>JNE</code></td>
<td>Jump if <code>out != 0</code></td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>0</code></td>
<td><code>JLE</code></td>
<td>Jump if <code>out &lt;= 0</code></td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
<td><code>JMP</code></td>
<td>Jump unconditionally</td>
</tr>
</tbody></table>
<p>The <code>JMP</code> is used as <code>0;JMP</code>. This is because the C-instruction syntax requires that we always effect some computation, we instruct the ALU to compute <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> (an arbitrary choice), which is ignored.</p>
<hr>
<p>Example: We want the computer to increment the value of <code>DataMemory[7]</code> by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> and to also store the result in the <code>D</code> register. This can be achieved with the following instructions:</p>
<pre><code class="hljs language-binary"> 0000 0000 0000 0111 // @7
 1111 1101 1101 1000 // MD=M+1
</code></pre><hr>
<p>Assembly commands can refer to memory addresses using either constants or symbols. Symbols are introduced into assembly programs in the following three ways:</p>
<ol>
<li>Predefined symbols: A subset of RAM addresses have predefined symbols:<ul>
<li>Virtual registers: The symbols <code>R0</code> to <code>R15</code> refer to RAM addresses <code>0</code> to <code>15</code>, respectively.</li>
<li>Predefined pointers: The symbols <code>SP</code>, <code>LCL</code>, <code>ARG</code>, <code>THIS</code>, and <code>THAT</code> refer to RAM addresses <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, and <code>4</code>, respectively.</li>
<li>I/O pointers: The symbols <code>SCREEN</code> and <code>KBD</code> refer to RAM addresses <code>16384</code> (0x4000) and <code>24576</code> (0x6000), respectively, which are the base addresses of the screen and
 keyboard memory maps.</li>
</ul>
</li>
<li>Label symbols: These are user-defined symbols serve to label destinations of goto commands. They are declared by the pseudo-command <code>(Xxx)</code>. This directive defines the symbol
<code>Xxx</code> to refer to the ROM address holding the next command in the program.</li>
<li>Variable symbols: Any user-defined symbol <code>Xxx</code> that appears in an assembly program without being predefined or declared as a label is treated as a variable.
The assembler allocates a unique RAM address for each appearance of such a symbol and replaces the symbol with its RAM address in the assembly program.
The instruction is of the form <code>@value</code>, where <code>value</code> is a $15$-bit constant.</li>
</ol>
<hr>
<p>The Hack platform can be connected to two peripheral devices: a screen and a keyboard.
Both devices interact with the computer platform through memory maps.
This means that drawing pixels on the screen is achieved by writing binary values into a memory segment associated with the screen.
Likewise, listening to the keyboard is done by reading a memory location associated with the keyboard.
The physical I/O devices and their memory maps are synchronized via continuous refresh loops.</p>
<hr>
<p>The Hack computer includes a black-and-white screen organized as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>256</mn></mrow><annotation encoding="application/x-tex">256</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">256</span></span></span></span> rows of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>512</mn></mrow><annotation encoding="application/x-tex">512</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">512</span></span></span></span> pixels per row.
The screen’s contents are represented by an 8K memory map that starts at RAM address <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16384</mn></mrow><annotation encoding="application/x-tex">16384</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16384</span></span></span></span> ($0x4000$).
Each row in the physical screen, starting at the screen’s top left corner, is represented in the RAM by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span></span></span></span> consecutive $16$-bit words.
Thus, the pixel at row <code>r</code> from the top and column <code>c</code> from the left is mapped on the <code>c%16</code> bit (counting from LSB to MSB) of the word located at <code>RAM[16384 + r * 32 + c/16]</code>.
To write or read a pixel of the physical screen, one reads or writes the corresponding bit in the RAM-resident memory map (1 = black, 0 = white).</p>
<p>Example:</p>
<pre><code class="hljs language-hack">// Draw a single black dot at the screen&#x27;s top left corner:
@SCREEN // Set the A register to point to the memory
       // word that is mapped to the 16 left-most
      // pixels of the top row of the screen.
M=1 // Blacken the left-most pixel.
</code></pre><hr>
<p>The Hack computer interfaces with the physical keyboard via a single-word memory map located in RAM address <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>24576</mn></mrow><annotation encoding="application/x-tex">24576</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">24576</span></span></span></span> ($0x6000$).
Whenever a key is pressed on the physical keyboard, its $16$-bit ASCII code appears in <code>RAM[24576]</code>.
When no key is pressed, the code <code>0</code> appears in this location.
In addition to the usual ASCII codes, the Hack keyboard recognizes the keys shown below.</p>
<table>
<thead>
<tr>
<th>Key pressed</th>
<th>Code</th>
</tr>
</thead>
<tbody><tr>
<td>newline</td>
<td>128</td>
</tr>
<tr>
<td>backspace</td>
<td>129</td>
</tr>
<tr>
<td>left arrow</td>
<td>130</td>
</tr>
<tr>
<td>up arrow</td>
<td>131</td>
</tr>
<tr>
<td>right arrow</td>
<td>132</td>
</tr>
<tr>
<td>down arrow</td>
<td>133</td>
</tr>
<tr>
<td>home</td>
<td>134</td>
</tr>
<tr>
<td>end</td>
<td>135</td>
</tr>
<tr>
<td>page up</td>
<td>136</td>
</tr>
<tr>
<td>page down</td>
<td>137</td>
</tr>
<tr>
<td>insert</td>
<td>138</td>
</tr>
<tr>
<td>delete</td>
<td>139</td>
</tr>
<tr>
<td>esc</td>
<td>140</td>
</tr>
<tr>
<td>f1-f2</td>
<td>141-152</td>
</tr>
</tbody></table>

    </body>
</html>